\documentclass[11pt]{report}
\usepackage{listings}
\usepackage{color}
%New colors defined below
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  basicstyle=\tiny\texttt,
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}

%"mystyle" code listing set
\lstset{style=mystyle}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
 
\urlstyle{same}

\usepackage{geometry}
 \geometry{
 a4paper,
 total={210mm,297mm},
 left=30mm,
 right=30mm,
 top=30mm,
 bottom=30mm,
 }

\title{Algorithm Code Book}
\author{Tanvir Hasan Anick}


\begin{document}
\maketitle
\tableofcontents
\newpage

%%Begin Data Structure
\chapter{Data Structure}
\section{Trie}
\subsection{Static Trie}
\lstinputlisting[language=C++]{../Algorithm/Trie/StaticTrie.cpp}
\section{RMQ}
\subsection{Bit}
\subsubsection{1D Bit}
\lstinputlisting[language=C++]{../Algorithm/Bit/Bit(1D).cpp}
\subsubsection{2D Bit}
\lstinputlisting[language=C++]{../Algorithm/Bit/Bit(2D).cpp}
\subsection{Square Root Decompostion}
\lstinputlisting[language=C++]{../Algorithm/Square_Root_Decomposition/squareRootDecomposition.cpp}
\subsection{MO's Algorithm}
\lstinputlisting[language=C++]{../Algorithm/MOs_Algorithm/MOs_Algorithm.cpp}
\subsection{Segment Tree}
\subsubsection{Lazy Propagration1}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Segment_Tree/Segment_Tree_Lazy1.cpp}
\subsubsection{Lazy Propagration2}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Segment_Tree/Segment_Tree_Lazy2.cpp}
\subsubsection{Segment Tree Variant 1}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Segment_Tree/Segment_Tree_Variant1(CumulativeFrequency).cpp}
\subsubsection{Segment Tree Variant 2}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Segment_Tree/Segment_Tree_Variant2(Maximum_sum_in_range).cpp}
\subsubsection{Segment Tree Variant 3}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Segment_Tree/Segment_Tree_Variant3(Correct_maximum_bracket_seq).cpp}
\subsection{Sliding Window RMQ}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Sliding_Window/Sliding_Window_Rmq.cpp}
\subsection{Sparse Table}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Sparse_Table/Sparse_Table.cpp}


\section{Ternary Bit Mask}
\lstinputlisting[language=C++]{../Algorithm/Ternary_Bit_Mask/Tarnary_Bit_Mask.cpp}

\section{Largest Rectangle in Histogram }
\subsection{Largest rectangle in histogram using Stack}
\lstinputlisting[language=C++]{../Algorithm/LargestRactangleInHistogram/LargestRactangleInHistogram_usingStack.cpp}
\subsection{Largest rectangle in histogram using Segment Tree}
\lstinputlisting[language=C++]{../Algorithm/LargestRactangleInHistogram/LargestRactangleInHistogram_usingSegmentTree.cpp}

\section{Least common ancestor (LCA)}
\lstinputlisting[language=C++]{../Algorithm/LCA/lca.cpp}
\section{Union Find}
\lstinputlisting[language=C++]{../Algorithm/UnionFind/UnionFind.cpp}
%%End Data Structure



%%Begin Graph Theory
\chapter{Graph Theory}
\section{DFS}
\subsection{Bicoloring}
\lstinputlisting[language=C++]{../Algorithm/DFS/Bicoloring.cpp}
\subsection{Cycle Finding}
\lstinputlisting[language=C++]{../Algorithm/DFS/Cycle_Finding.cpp}
\section{Topological Sort}
\lstinputlisting[language=C++]{../Algorithm/Topological_Sort/Top_Sort_With_Dfs.cpp}
\section{Strongly Connected Component}
\lstinputlisting[language=C++]{../Algorithm/SCC/StronglyConnectedComponent.cpp}
\section{Havel Hakimi}
\lstinputlisting[language=C++]{../Algorithm/Havel_Hakimi/HavelHakimi.cpp}
\section{Articulation Point/Bridge}
\subsection{Find Articulation Point:}
\lstinputlisting[language=C++]{../Algorithm/Articulation_point/FindArticulationPoint.cpp}
\subsection{Find Bridge version 1:}
\lstinputlisting[language=C++]{../Algorithm/Articulation_point/ArticulationPointFindBridge1.cpp}
\subsection{Find Bridge version 2:}
\lstinputlisting[language=C++]{../Algorithm/Articulation_point/ArticulationPointFindBridge2.cpp}
\section{Stable Marriage Problem}
\lstinputlisting[language=C++]{../Algorithm/StableMarriageAlgo/Stable_Marriage_Algo.cpp}
\section{2 SAT}
\lstinputlisting[language=C++]{../Algorithm/2SAT/2SAT.cpp}
\section{Heavy Light Decomposition}
\lstinputlisting[language=C++]{../Algorithm/HLD/Heavy_LIght_Decomposition.cpp}

%%End Graph Theory

%%Begin Flow networks/ matching
\chapter{Flow networks/ matching}
\section{Max Flow}
\lstinputlisting[language=C++]{../Algorithm/Max_Flow/Max_Flow.cpp}
\section{Maximum Bipartite Matching}
\lstinputlisting[language=C++]{../Algorithm/MaximumBipartiteMatching/BPM.cpp}
%%End Flow network/matching

%%Begin Dynamic programming
\chapter{Dynamic programming}
\section{Edit Distance}
\lstinputlisting[language=C++]{../Algorithm/Edit_Distance/Edit_Destance.cpp}
\section{Distinct Sub Sequence}
\lstinputlisting[language=C++]{../Algorithm/Distinct_Subsequnce/DistinctSubsequence.cpp}
\section{Knuth Optimization}
\lstinputlisting[language=C++]{../Algorithm/knuth_optimization/knuthOptimization.cpp}
\section{Max Sum}
\subsection{2D Max Sum 1}
Complexity $O(n^4)$
\lstinputlisting[language=C++]{../Algorithm/MaXSum/2DMaxSum.cpp}
\subsection{2D Max sum 2}
Complexity $n^3$
\lstinputlisting[language=C++]{../Algorithm/MaXSum/2DMaxSum_O(n^3).cpp}
\subsection{3D Max sum}
Complexity $O(n^4)$

Cumulative Sum formula: S(x,y,z)=value(x,y,z) + S(x-1,y,z) + S(x,y-1,z)+S(x,y,z-1)-S(x-1,y-1,z)-S(x,y-1,z-1)-S(x-1,y,z-1)
+S(x-1,y-1,z-1)\\ \\
Query Formula: S([x1,y1,z1] to [x2,y2,z2] )=S(x2,y2,z2)+S(x1,y1,z2)+S(x1,y2,z1)+S(x1,y1,z1)-S(x2,y2,z1)-S(x2,y1,z2)-S(x1,y2,z2)
-S(x1,y1,z1) \\ \\ 

\lstinputlisting[language=C++]{../Algorithm/MaXSum/3DMaxSum_O(n^4).cpp}

\section{Minimum Vertex Cover}
\lstinputlisting[language=C++]{../Algorithm/MinimumVertexCover/minimum_vertex_cover.cpp}
\section{Nth Permutation Of a String}
\lstinputlisting[language=C++]{../Algorithm/Nth_Permutation_Of_a_String/NthPermutation.cpp}
%%End Dynamic programming

%%Begin String algorithm
\chapter{Strings}
\section{KMP}
\href{https://tanvir002700.wordpress.com/2015/03/03/kmp-knuth-morris-pratt-algorithm/}{Tutorial}
\lstinputlisting[language=C++]{../Algorithm/KMP/kmp.cpp}
\section{Aho Corasick}
\subsection{Aho Corasick with Dynamic Trie}
\lstinputlisting[language=C++]{../Algorithm/Aho_Corasick/Aho-corasick(DynamicTrie).cpp}
\subsection{Aho Corasick with Static Trie}
\lstinputlisting[language=C++]{../Algorithm/Aho_Corasick/Aho-corasick(staticTrie).cpp}
\section{Manacher's Algorithm}
\lstinputlisting[language=C++]{../Algorithm/Manachers_Algorithm/Manachers.cpp}

%%End String Algorithm

%%Begin Math
\chapter{Math}
\section{Reduce Ratio}
$\left(\frac{A}{B}\right)$ ratio reduce to $\left(\frac{x}{y}\right)$
\lstinputlisting[language=C++]{../Algorithm/Math/A,B_reduce_to_x,y_ratio.cpp}
\section{Floyd's Cycle Finding algorithm}
\lstinputlisting[language=C++]{../Algorithm/Floyds_Cycle_Finding_algorithm/FloydsCycleFindingAlgorithm.cpp}
\section{Angle between clock hand}
\lstinputlisting[language=C++]{../Algorithm/Math/Angle_between_clock_hand.cpp}
\section{Big Integer}
\lstinputlisting[language=C++]{../Algorithm/BigInteger/BigInt.cpp}
%%End Math

%%Begin Game Theory

\chapter{Game Theory}
\section{Min Max Algorithm}
\lstinputlisting[language=C++]{../Algorithm/MinMax_Algorithm/MINMAXALGORITHM.cpp}
%%End Game Theory

%%Begin Number Theory
\chapter{Number Theory}
\section{Greatest common divisor (GCD)}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/gcd.cpp}
\section{Least common multiple (LCM)}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/lcm.cpp}
\section{Big Mod}
\subsection{Iterative version}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/BigModLoop.cpp}
\subsection{Recursive version}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/BigModRucursive.cpp}
\section{Sieve of Eratosthenes}
\subsection{Sieve}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/Sieve.cpp}
\subsection{Bitwise Sieve}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/BitwiseSieve.cpp}
\section{Euler's totient function}
Euler's totient function (or Euler's phi function), denoted as $\varphi (n) or  \phi(n)$, is an arithmetic function that counts the positive integers less than or equal to n that are relatively prime to n. (These integers are sometimes referred to as totatives of n.) Thus, if n is a positive integer, then $\varphi (n)$ is the number of integers k in the range $1 \leq k \leq n$ for which the greatest common divisor gcd(n, k) = 1.
\subsection{Euler phi sieve version}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/EulerPhi(sieve_version).cpp}
\subsection{Euler phi function}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/EulerPhi.cpp}
\section{Number of Divisors}
If a number $$N= P1^{k1}*P2^{k2}*P3^{k3}………...........Pn^{kn}$$
Number of divisor: $$f(n)=(k1+1)*(k2+1)*(k3+1)*…….........….(kn+1)$$
\subsection{NOD sieve version}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/NumberOfDivisor(sieve_version).cpp}
\subsection{NOD function}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/NumberOfDivisor.cpp}
\section{Summation of Divisors}
If the prime factorization of an integer is:
		$$P1^{x1}*P2^{x2}*…….....…..*Pn^{xn}$$
Where $P1,P2,………Pn$ are primes, then the summation of divisors is
		$$\frac{(P1^{x1}  -1)}{(P1-1)} * \frac{(P2^{x2}  -1)}{(P2-1)} *………......... *\frac{(Pn^{xn}  -1)}{(Pn-1)}$$
\section{Extended Euclid GCD}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/ExtendedEuclidGCD.cpp}
\section{Modular multiplicative inverse}
\subsection{Modular inverse using EGCD}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/ModularInverse(EGCD).cpp}
\subsection{Modular multiplicative inverse using Euler Theorem}
According to Euler's theorem, if a is coprime to m, that is, gcd(a, m) = 1,then
$$a^{\varphi(m)} \equiv 1 \pmod{m}$$
where φ(m) is Euler's totient function. This follows from the fact that a belongs to the multiplicative group $(\frac{Z}{mZ})^×$ iff a is coprime to m. Therefore the modular multiplicative inverse can be found directly:
$$a^{\varphi(m)-1} \equiv a^{-1} \pmod{m}$$.
In the special case when m is a prime, the modular inverse is given by the below equation as:
$$a^{-1} \equiv a^{m-2} \pmod{m}$$.
\section{NCR}
\subsection{Lucas Theorem}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/NCR(LucasTheorem).cpp}

%%End Number Theory

%%Begin Computational Geometry
\chapter{Computational geometry}
\section{Geo Library}
\lstinputlisting[language=C++]{../Algorithm/GeometryLibrary/GeoLibrary.cpp}
%%End Computational Geometry

\end{document}