\documentclass[11pt]{report}
\usepackage{listings}
\usepackage{color}
\usepackage[top=1in, bottom=1in, left=1.25in, right=1.25in]{geometry}
\usepackage{graphicx}
%New colors defined below
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  basicstyle=\tiny\texttt,
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}

%"mystyle" code listing set
\lstset{style=mystyle}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
 
\urlstyle{same}

\usepackage{geometry}
 \geometry{
 a4paper,
 total={210mm,297mm},
 left=30mm,
 right=30mm,
 top=30mm,
 bottom=30mm,
 }

\title{Algorithm Code Book}
\author{Tanvir Hasan Anick}


\begin{document}
\maketitle
\tableofcontents
\newpage

%%Begin Data Structure
\chapter{Data Structure}
\section{Trie}
\subsection{Static Trie}
\lstinputlisting[language=C++]{../Algorithm/Trie/StaticTrie.cpp}
\section{RMQ}
\subsection{Bit}
\subsubsection{1D Bit}
\lstinputlisting[language=C++]{../Algorithm/Bit/Bit(1D).cpp}
\subsubsection{2D Bit}
\lstinputlisting[language=C++]{../Algorithm/Bit/Bit(2D).cpp}
\subsection{Square Root Decompostion}
\lstinputlisting[language=C++]{../Algorithm/Square_Root_Decomposition/squareRootDecomposition.cpp}
\subsection{MO's Algorithm}
\lstinputlisting[language=C++]{../Algorithm/MOs_Algorithm/MOs_Algorithm.cpp}
\subsection{Segment Tree}
\subsubsection{Lazy Propagration1}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Segment_Tree/Segment_Tree_Lazy1.cpp}
\subsubsection{Lazy Propagration2}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Segment_Tree/Segment_Tree_Lazy2.cpp}
\subsubsection{Segment Tree Variant 1}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Segment_Tree/Segment_Tree_Variant1(CumulativeFrequency).cpp}
\newpage
\subsubsection{Segment Tree Variant 2}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Segment_Tree/Segment_Tree_Variant2(Maximum_sum_in_range).cpp}
\subsubsection{Segment Tree Variant 3}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Segment_Tree/Segment_Tree_Variant3(Correct_maximum_bracket_seq).cpp}
\subsection{Sliding Window RMQ}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Sliding_Window/Sliding_Window_Rmq.cpp}
\newpage
\subsection{Sparse Table}
\lstinputlisting[language=C++]{../Algorithm/RMQ-Sparse_Table/Sparse_Table.cpp}


\section{Ternary Bit Mask}
\lstinputlisting[language=C++]{../Algorithm/Ternary_Bit_Mask/Tarnary_Bit_Mask.cpp}

\section{Largest Rectangle in Histogram }
\subsection{Largest rectangle in histogram using Stack}
\lstinputlisting[language=C++]{../Algorithm/LargestRactangleInHistogram/LargestRactangleInHistogram_usingStack.cpp}
\subsection{Largest rectangle in histogram using Segment Tree}
\lstinputlisting[language=C++]{../Algorithm/LargestRactangleInHistogram/LargestRactangleInHistogram_usingSegmentTree.cpp}

\section{Least common ancestor (LCA)}
\lstinputlisting[language=C++]{../Algorithm/LCA/lca.cpp}
\newpage
\section{Union Find}
\lstinputlisting[language=C++]{../Algorithm/UnionFind/UnionFind.cpp}
%%End Data Structure



%%Begin Graph Theory
\chapter{Graph Theory}
\section{DFS}
\subsection{Bicoloring}
\lstinputlisting[language=C++]{../Algorithm/DFS/Bicoloring.cpp}
\subsection{Cycle Finding}
\lstinputlisting[language=C++]{../Algorithm/DFS/Cycle_Finding.cpp}
\section{Topological Sort}
\lstinputlisting[language=C++]{../Algorithm/Topological_Sort/Top_Sort_With_Dfs.cpp}
\section{Strongly Connected Component}
\lstinputlisting[language=C++]{../Algorithm/SCC/StronglyConnectedComponent.cpp}
\section{Havel Hakimi}
Given N degree d1,d2,d3.....dn. Is it possible to make a graph which have no cycle and
different two node will be connected with one Edge?\\
\includegraphics[scale=1.5,width=10cm,height=8cm]{../Algorithm/Havel_Hakimi/havelhakimi.png}\\ \\
\lstinputlisting[language=C++]{../Algorithm/Havel_Hakimi/HavelHakimi.cpp}
\section{Articulation Point/Bridge}
\textbf{Articulation point:}
A vertex in an undirected connected graph is an articulation point (or cut vertex) iff removing it (and edges through it) disconnects the graph. Articulation points represent vulnerabilities in a connected network â€“ single points whose failure would split the network into 2 or more disconnected components. They are useful for designing reliable networks.
For a disconnected undirected graph, an articulation point is a vertex removing which increases number of connected components.
Following are some example graphs with articulation points encircled with red color.
\begin{figure}[h]
\begin{center}$
\begin{array}{cc}
\includegraphics[width=4cm, height=5cm]{../Algorithm/Articulation_point/ArticulationPoints.png}
\includegraphics[width=4cm, height=5cm]{../Algorithm/Articulation_point/ArticulationPoints1.png}
\includegraphics[width=4cm, height=5cm]{../Algorithm/Articulation_point/ArticulationPoints21.png}
\end{array}$
\end{center}
\caption{Articulation Point}
\end{figure}\\
\textbf{A O(V+E) algorithm to find all Articulation Points: } \\
The idea is to use DFS (Depth First Search). In DFS, we follow vertices in tree form called DFS tree. In DFS tree, a vertex u is parent of another vertex v, if v is discovered by u (obviously v is an adjacent of u in graph). In DFS tree, a vertex u is articulation point if one of the following two conditions is true.
\begin{enumerate}
\item u is root of DFS tree and it has at least two children.
\item  u is not root of DFS tree and it has a child v such that no vertex in subtree rooted with v has a back edge to one of the ancestors (in DFS tree) of u.
\end{enumerate}
 u is not root of DFS tree and it has a child v such that no vertex in subtree rooted with v has a back edge to one of the ancestors (in DFS tree) of u.
 \begin{figure}[h]
\begin{center}$
\begin{array}{cc}
\includegraphics[width=8cm, height=6cm]{../Algorithm/Articulation_point/ArticulationPoints4.png}
\end{array}$
\end{center}
\caption{Articulation Point}
\end{figure}\\
We do DFS traversal of given graph with additional code to find out Articulation Points (APs). In DFS traversal, we maintain a parent[] array where parent[u] stores parent of vertex u. Among the above mentioned two cases, the first case is simple to detect. For every vertex, count children. If currently visited vertex u is root (parent[u] is NIL) and has more than two children, print it.
How to handle second case? The second case is trickier. We maintain an array disc[] to store discovery time of vertices. For every node u, we need to find out the earliest visited vertex (the vertex with minimum discovery time) that can be reached from subtree rooted with u. So we maintain an additional array low[] which is defined as follows.\\
low[u] = min(disc[u], disc[w]) \\
where w is an ancestor of u and there is a back edge from 
some descendant of u to w.
\subsection{Find Articulation Point:}
\lstinputlisting[language=C++]{../Algorithm/Articulation_point/FindArticulationPoint.cpp}
\subsection{Find Bridge version 1:}
\lstinputlisting[language=C++]{../Algorithm/Articulation_point/ArticulationPointFindBridge1.cpp}
\subsection{Find Bridge version 2:}
\lstinputlisting[language=C++]{../Algorithm/Articulation_point/ArticulationPointFindBridge2.cpp}
\newpage
\section{Stable Marriage Problem}
\lstinputlisting[language=C++]{../Algorithm/StableMarriageAlgo/Stable_Marriage_Algo.cpp}
\section{2 SAT}
\lstinputlisting[language=C++]{../Algorithm/2SAT/2SAT.cpp}
\section{Heavy Light Decomposition}
\lstinputlisting[language=C++]{../Algorithm/HLD/Heavy_LIght_Decomposition.cpp}

%%End Graph Theory

%%Begin Flow networks/ matching
\chapter{Flow networks, matching}
\section{Max Flow}
\lstinputlisting[language=C++]{../Algorithm/Max_Flow/Max_Flow.cpp}
\newpage
\section{Maximum Bipartite Matching}
\lstinputlisting[language=C++]{../Algorithm/MaximumBipartiteMatching/BPM.cpp}
%%End Flow network/matching

%%Begin Dynamic programming
\chapter{Dynamic programming}
\section{Longest Increasing sub sequence}
\subsection{LIS1}
\lstinputlisting[language=C++]{../Algorithm/LIS/LIS1.cpp}
\subsection{LIS(Stanford)}
\lstinputlisting[language=C++]{../Algorithm/LIS/LIS(stanford).cpp}
\section{Edit Distance}
\lstinputlisting[language=C++]{../Algorithm/Edit_Distance/Edit_Destance.cpp}
\section{Distinct Sub Sequence}
\lstinputlisting[language=C++]{../Algorithm/Distinct_Subsequnce/DistinctSubsequence.cpp}
\section{Knuth Optimization}
\lstinputlisting[language=C++]{../Algorithm/knuth_optimization/knuthOptimization.cpp}
\section{Max Sum}
\subsection{2D Max Sum 1}
Complexity $O(n^4)$
\lstinputlisting[language=C++]{../Algorithm/MaXSum/2DMaxSum.cpp}
\subsection{2D Max sum 2}
Complexity $n^3$
\lstinputlisting[language=C++]{../Algorithm/MaXSum/2DMaxSum_O(n^3).cpp}
\subsection{3D Max sum}
Complexity $O(n^4)$

Cumulative Sum formula: S(x,y,z)=value(x,y,z) + S(x-1,y,z) + S(x,y-1,z)+S(x,y,z-1)-S(x-1,y-1,z)-S(x,y-1,z-1)-S(x-1,y,z-1)
+S(x-1,y-1,z-1)\\ \\
Query Formula: S([x1,y1,z1] to [x2,y2,z2] )=S(x2,y2,z2)+S(x1,y1,z2)+S(x1,y2,z1)+S(x1,y1,z1)-S(x2,y2,z1)-S(x2,y1,z2)-S(x1,y2,z2)
-S(x1,y1,z1) \\ \\ 

\lstinputlisting[language=C++]{../Algorithm/MaXSum/3DMaxSum_O(n^4).cpp}

\section{Minimum Vertex Cover}
\lstinputlisting[language=C++]{../Algorithm/MinimumVertexCover/minimum_vertex_cover.cpp}
\newpage
\section{Nth Permutation Of a String}
\lstinputlisting[language=C++]{../Algorithm/Nth_Permutation_Of_a_String/NthPermutation.cpp}
%%End Dynamic programming

%%Begin String algorithm
\chapter{Strings}
\section{KMP}
\href{https://tanvir002700.wordpress.com/2015/03/03/kmp-knuth-morris-pratt-algorithm/}{Tutorial}
\lstinputlisting[language=C++]{../Algorithm/KMP/kmp.cpp}
\section{Aho Corasick}
\textbf{Algorithm:}
We can divide the algorithm into 2 steps:
\begin{enumerate}
	\item constructing a finite state automaton
	\begin{itemize}
		\item constructing a Trie with input words
		\item finding the right fall function for each node of trie
	\end{itemize}
\item moving throuhg automaton - reading each character from input, storing the results.  If an algorithm finds right words in some step, (more words can end in the same place), the nodes light up and the numbers by their indices are incremented.
\end{enumerate}

\subsection{Aho Corasick with Dynamic Trie}
\lstinputlisting[language=C++]{../Algorithm/Aho_Corasick/Aho-corasick(DynamicTrie).cpp}
\subsection{Aho Corasick with Static Trie}
\lstinputlisting[language=C++]{../Algorithm/Aho_Corasick/Aho-corasick(staticTrie).cpp}
\section{Manacher's Algorithm}
\lstinputlisting[language=C++]{../Algorithm/Manachers_Algorithm/Manachers.cpp}
\section{Suffix Array}
\subsection{Suffix Array $N{log}^2N$ complexity:}
\lstinputlisting[language=C++]{../Algorithm/Suffix_Array/SuffixArray_N(logN^2).cpp}
\newpage
\subsection{Suffix Array $NlogN$ complexity: }
\lstinputlisting[language=C++]{../Algorithm/Suffix_Array/SuffixArray_NlogN.cpp}
\subsection{Longest common sub sequence: }
\lstinputlisting[language=C++]{../Algorithm/Suffix_Array/longestSubstringWithBinarySearchAndLcp.cpp}
\newpage
\subsection{Number of Distinct sub sequence: }
\lstinputlisting[language=C++]{../Algorithm/Suffix_Array/NumberofDistinctSubsequence.cpp}
%%End String Algorithm

%%Begin Math
\chapter{Math}
\section{Pick's Theorem: }
$Area=\frac{B}{2}+I-1$
\section{Reduce Ratio}
$\left(\frac{A}{B}\right)$ ratio reduce to $\left(\frac{x}{y}\right)$
\lstinputlisting[language=C++]{../Algorithm/Math/A,B_reduce_to_x,y_ratio.cpp}
\section{Floyd's Cycle Finding algorithm}
\lstinputlisting[language=C++]{../Algorithm/Floyds_Cycle_Finding_algorithm/FloydsCycleFindingAlgorithm.cpp}
\section{Angle between clock hand}
\lstinputlisting[language=C++]{../Algorithm/Math/Angle_between_clock_hand.cpp}
\section{Big Integer}
\lstinputlisting[language=C++]{../Algorithm/BigInteger/BigInt.cpp}
%%End Math

%%Begin Game Theory

\chapter{Game Theory}
\section{Min Max Algorithm}
\lstinputlisting[language=C++]{../Algorithm/MinMax_Algorithm/MINMAXALGORITHM.cpp}
\newpage
\section{Grundy Number}
\lstinputlisting[language=C++]{../Algorithm/Grundy_Number/Grundy.cpp}
%%End Game Theory

%%Begin Number Theory
\chapter{Number Theory}
\section{Greatest common divisor (GCD)}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/gcd.cpp}
\section{Least common multiple (LCM)}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/lcm.cpp}
\section{Big Mod}
\subsection{Iterative version}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/BigModLoop.cpp}
\subsection{Recursive version}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/BigModRucursive.cpp}
\section{Sieve of Eratosthenes}
\subsection{Sieve}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/Sieve.cpp}
\subsection{Bitwise Sieve}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/BitwiseSieve.cpp}
\section{Euler's totient function}
Euler's totient function (or Euler's phi function), denoted as $\varphi (n) or  \phi(n)$, is an arithmetic function that counts the positive integers less than or equal to n that are relatively prime to n. (These integers are sometimes referred to as totatives of n.) Thus, if n is a positive integer, then $\varphi (n)$ is the number of integers k in the range $1 \leq k \leq n$ for which the greatest common divisor gcd(n, k) = 1.
\subsection{Euler phi sieve version}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/EulerPhi(sieve_version).cpp}
\subsection{Euler phi function}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/EulerPhi.cpp}
\newpage
\section{Number of Divisors}
If a number $$N= P1^{k1}*P2^{k2}*P3^{k3}â€¦â€¦â€¦...........Pn^{kn}$$
Number of divisor: $$f(n)=(k1+1)*(k2+1)*(k3+1)*â€¦â€¦.........â€¦.(kn+1)$$
\subsection{NOD sieve version}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/NumberOfDivisor(sieve_version).cpp}
\subsection{NOD function}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/NumberOfDivisor.cpp}
\section{Summation of Divisors}
If the prime factorization of an integer is:
		$$P1^{x1}*P2^{x2}*â€¦â€¦.....â€¦..*Pn^{xn}$$
Where $P1,P2,â€¦â€¦â€¦Pn$ are primes, then the summation of divisors is
		$$\frac{(P1^{x1}  -1)}{(P1-1)} * \frac{(P2^{x2}  -1)}{(P2-1)} *â€¦â€¦â€¦......... *\frac{(Pn^{xn}  -1)}{(Pn-1)}$$
\section{Extended Euclid GCD}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/ExtendedEuclidGCD.cpp}
\section{Modular multiplicative inverse}
\subsection{Modular inverse using EGCD}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/ModularInverse(EGCD).cpp}
\subsection{Modular multiplicative inverse using Euler Theorem}
According to Euler's theorem, if a is coprime to m, that is, gcd(a, m) = 1,then
$$a^{\varphi(m)} \equiv 1 \pmod{m}$$
where Ï†(m) is Euler's totient function. This follows from the fact that a belongs to the multiplicative group $(\frac{Z}{mZ})^Ã—$ iff a is coprime to m. Therefore the modular multiplicative inverse can be found directly:
$$a^{\varphi(m)-1} \equiv a^{-1} \pmod{m}$$.
In the special case when m is a prime, the modular inverse is given by the below equation as:
$$a^{-1} \equiv a^{m-2} \pmod{m}$$.
\section{NCR}
\subsection{Lucas Theorem}
\lstinputlisting[language=C++]{../Algorithm/Number_Theory/NCR(LucasTheorem).cpp}

%%End Number Theory

%%Begin Computational Geometry
\chapter{Computational geometry}
\section{Geo Library (Stanford)}
\lstinputlisting[language=C++]{../Algorithm/GeometryLibrary/GeoLibrary.cpp}
\section{Convex Hull}
\subsection{Convex Hull 1}
\lstinputlisting[language=C++]{../Algorithm/Computational_Geometry/ConvexHull.cpp}
\subsection{Convex Hull (Stanford)}
\lstinputlisting[language=C++]{../Algorithm/Computational_Geometry/ConvexHull(Stanford).cpp}
\section{Determine a point inside polygon or not}
\lstinputlisting[language=C++]{../Algorithm/Computational_Geometry/Determine_a_point_inside_polygon_or_not.cpp}
\section{Integer point in a Segment or lattice point}
\lstinputlisting[language=C++]{../Algorithm/Computational_Geometry/IntegerPointInsegment.cpp}
\section{Segment Intersection}
\lstinputlisting[language=C++]{../Algorithm/Computational_Geometry/Segment_intersection.cpp}
\section{Verify Convex polygon}
\lstinputlisting[language=C++]{../Algorithm/Computational_Geometry/Verify_convex_polygon.cpp}
\section{Closest Pair Algorithm}
\lstinputlisting[language=C++]{../Algorithm/Computational_Geometry/ClosestPair.cpp}
%%End Computational Geometry

\end{document}